cyclicTree	compiler/trees.html#cyclicTree,PNode	trees: cyclicTree(n: PNode): bool	
exprStructuralEquivalent	compiler/trees.html#exprStructuralEquivalent,PNode,PNode	trees: exprStructuralEquivalent(a, b: PNode; strictSymEquality = false): bool	
sameTree	compiler/trees.html#sameTree,PNode,PNode	trees: sameTree(a, b: PNode): bool	
getMagic	compiler/trees.html#getMagic,PNode	trees: getMagic(op: PNode): TMagic	
isConstExpr	compiler/trees.html#isConstExpr,PNode	trees: isConstExpr(n: PNode): bool	
isCaseObj	compiler/trees.html#isCaseObj,PNode	trees: isCaseObj(n: PNode): bool	
isDeepConstExpr	compiler/trees.html#isDeepConstExpr,PNode	trees: isDeepConstExpr(n: PNode; preventInheritance = false): bool	
isRange	compiler/trees.html#isRange,PNode	trees: isRange(n: PNode): bool	
whichPragma	compiler/trees.html#whichPragma,PNode	trees: whichPragma(n: PNode): TSpecialWord	
findPragma	compiler/trees.html#findPragma,PNode,TSpecialWord	trees: findPragma(n: PNode; which: TSpecialWord): PNode	
effectSpec	compiler/trees.html#effectSpec,PNode,TSpecialWord	trees: effectSpec(n: PNode; effectType: TSpecialWord): PNode	
flattenStmts	compiler/trees.html#flattenStmts,PNode	trees: flattenStmts(n: PNode): PNode	
extractRange	compiler/trees.html#extractRange,TNodeKind,PNode,int,int	trees: extractRange(k: TNodeKind; n: PNode; a, b: int): PNode	
